# 数组

## 03-数组中重复的数字

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

基数排序法  时间O(n)  空间O(1)

* 判断输入数组有无元素非法
* 从头扫到尾，只要当前元素值与下标不同，就做一次判断,numbers[i]与numbers[numbers[i]]，相等就认为找到了
* 重复元素，返回true,否则就交换两者，继续循环。直到最后还没找到认为没找到重复元素，返回false。

## 04-二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

减而治之 时间 O(m+n) 空间O(1)

* 从左下角开始遍历，当该值小于 target 值时，向右搜索；大于 target 值时，向上搜索。如果找到 target 则返回 True，否则返回 False。

* 最坏情况下，我们从左下角移动到右上角

## 21-调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分

首尾双指针 时间O(n) 空间O(1)

* 定义头指针left，尾指针right
* left一直往右移，直到它指向的值为偶数
* right一直往左移，直到它指向的值为奇数。
* 交换nums[left]和nums[right]
* 重复上述操作，直到left==right

## 29-顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

四边界顺时针打印 时间O(mn) 空间O(1)

顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。

初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。

循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事：

* 根据边界打印，即将元素按顺序添加至列表 res 尾部；
* 边界向内收缩 1 （代表已被打印）；
* 判断是否打印完毕（边界是否相遇），若打印完毕则跳出。

| 打印方向	  1. 根据边界打印	      2. 边界向内收缩	    3. 是否打印完毕 |      |      |      |
| ------------------------------------------------------------ | ---- | ---- | ---- |
| 从左向右	  左边界l ，右边界 r	     上边界 t 加 1	       是否 t > b |      |      |      |
| 从上向下	  上边界 t ，下边界b	    右边界 r 减 1	      是否 l > r |      |      |      |
| 从右向左	  右边界 r ，左边界l	     下边界 b 减 1	      是否 t > b |      |      |      |
| 从下向上	  下边界 b ，上边界t	    左边界 l 加 1	      是否 l > r |      |      |      |

## 53-I 在排序数组中查找数字I

## 53-II 0～n-1中缺失的数字

## 39 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。

* 先将数组进行快排，如果数组中有一个数字出现的次数超过数组长度的一半，那么快排后数组中间的数就一定是这个数字。
* 遍历快排后的数组，如果最中间的数的个数大于数组长度的一半，则输出这个数，否则输出0；

## 66-构建乘积数组

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

对称遍历，B[i] 就是 A[i] 左边所有元素的积 乘 A[i] 右边所有元素的积。

* 从左往右遍历累乘，结果保存在数组ret 中，此时ret[i] 表示，A[i] 左边所有元素的乘积
* 然后从右往左遍历累乘，获取A[i] 右边所有元素的乘积
* 两边遍历之后得到的ret，就是最终结果

## 11-旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 numbers[x] ，称 x 为 旋转点 。

排序数组的查找问题首先考虑使用 二分法 解决，可将遍历法的 线性级别 时间复杂度降低至 对数级别 。

# 动态规划

## 14-I 剪绳子

 * 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。
 * 当然也可能有4，但是4=2x2，我们就简单些不考虑了。
 * 5<2x3,6<3x3,比6更大的数字我们就更不用考虑了，肯定要继续分。
 * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2x2x2<3x3，那么题目就简单了。
 * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。
 * 由于题目规定m>1，所以2只能是1x1，3只能是2x1，这两个特殊情况直接返回就行了。
 * 乘方运算的复杂度为：O(log n)，用动态规划来做会耗时比较多。

## 42-连续子数组的最大和

dp[i]表示以元素array[i]结尾的最大连续子数组和.

以[-2,-3,4,-1,-2,1,5,-3]为例，可以发现：

dp[0] = -2
dp[1] = -3
dp[2] = 4
dp[3] = 3

以此类推,会发现，dp[i] = max{dp[i-1]+array[i],array[i]}.

## 10-I 斐波那契数列

大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。

## 10-II 青蛙跳台阶问题

对于本题,前提只有 一次 1阶或者2阶的跳法。

a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);

b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)

c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2) 

d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2

# 哈希表

## 50-第一个只出现一次的字符

## 48-最长不含重复字符的子字符串

# 堆

## 40-最小的k个数

用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。

## 41-数据流中的中位数

思路：两个堆，自己实现，一个最大堆，一个最小堆

用一个大顶堆和一个小顶堆，维持大顶堆的数都小于等于小顶堆的数，且两者的个数相等或差1。平均数就在两个堆顶的数之中。

# 链表

## 18-删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。

## 06-从尾到头打印链表

先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。

时间复杂度O(N)： 遍历链表，递归 N 次。空间复杂度O(N)： 系统递归需要使用 O(N) 的栈空间。

## 22-链表中倒数第K个节点

输入一个链表，输出该链表中倒数第k个结点。
“相当于制造了一个K长度的尺子，把尺子从头往后移动，当尺子的右端与链表的末尾对齐的时候，尺子左端所在的结点就是倒数第k个结点”

## 24-反转链表

* pHead始终指向要反转的结点
* last 指向反转后的首结点
* 每反转一个结点，把pHead结点的下一个结点指向last, last指向pHead成为反转后首结点, 再把pHead向前移动一个结点直至None结束

## 35-复杂链表的复制

* 复制每个节点，如：复制节点A得到A1，将A1插入节点A后面
* 遍历链表，A1->random = A->random->next;
* 将链表拆分成原链表和复制后的链表

## 52-两个链表的第一个公共节点

## 25-合并两个排序的链表

# 栈和队列

## 59-I 滑动窗口的最大值

## 09-用两个栈实现队列

## 30-包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

* 思路：利用一个辅助栈来存放最小值
* 栈  3，4，2，5，1
* 辅助栈 3，3，2，2，1
* 每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶。当出栈时，辅助栈也要出栈。
* 这种做法可以保证辅助栈顶一定都当前栈的最小值。

## 59-II 队列的最大值

## 31-栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

模拟栈 贪心算法 时间O(n) 空间O(n)

尝试按照 popped 中的顺序模拟一下出栈操作，如果符合则返回 true，否则返回 false。这里用到的贪心法则是如果栈顶元素等于 popped 序列中下一个要 pop 的值，则应立刻将该值 pop 出来。

使用一个栈 st 来模拟该操作。将 pushed 数组中的每个数依次入栈，同时判断这个数是不是 popped 数组中下一个要 pop 的值，如果是就把它 pop 出来。最后检查栈是否为空。

# 字符串

## 05-替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

* 初始化一个 list ，记为 res 
* 遍历列表 s 中的每个字符 c
* 当 c 为空格时：向 res 后添加字符串 "%20"
* 当 c 不为空格时：向 res 后添加字符 c 
* 将列表 res 转化为字符串并返回。

## 19-正则表达式匹配

* 请实现一个函数用来匹配包括'.'和'*'的正则表达式。
* 模式中的字符'.'表示任意一个字符（不包括空字符！），而'*'表示它前面的字符可以出现任意次（包含0次）。 
* 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

## 20-表示数值的字符串

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"、"-1E-16"及"12e+5.4"都不是。

## 38-字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

回溯递归

对于一个长度为 n 的字符串（假设字符互不重复），其排列共有n×(n−1)×(n−2)…×2×1 种方案。

# 二叉树

## 26-树的子结构

* 1.在树A中找到和B的根节点的值一样的结点R；递归的方法来遍历整棵树。
* 2.第二步再判断树A中以R为根结点的子树是不是包含和树B一样的结构。递归的终止条件是我们达到了树A或者树B的叶节点。

## 28-对称的二叉树

思路：
根节点以及其左右子树，左子树的左子树和右子树的右子树相同左子树的右子树和右子树的左子树相同即对称；
采用递归、非递归均可；
采用栈或队列存取各级子树根节点；

递归比较左右节点，然后对左右节点的左右分支进一步递归比较

## 37-序列化二叉树

## 07-重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

* 递归思想，每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，
* 然后递归求解，直到startPre>endPre||startIn>endIn说明子树整理完到。方法每次返回左子树或右子树的根节点
* 重建时先建立左子树时，会将pre中的内容一个个pop掉，这样到建立右子树时，pre中已经不包含左子树中的内容了。

## 54-二叉搜索树的第k大节点

思路：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。

所以，按照中序遍历顺序找到第k个结点就是结果。

## 68-I 二叉搜索树的最近公共祖先

## 68-II 二叉树的最近公共祖先

## 27-二叉树的镜像

* 先中序遍历，将所有的节点保存到一个列表中。
* 对这个list[:-1]进行遍历，每个节点的right设为下一个节点，下一个节点的left设为上一个节点。

## 28-对称的二叉树

# BFS

## 32-I 从上到下打印二叉树 I

## 32-II 从上到下打印二叉树 II

## 32-III 从上到下打印二叉树 III

# DFS

## 34-二叉树中和为某一值的路径

* 递归先序遍历树， 把结点加入路径。
* 若该结点是叶子结点则比较当前路径和是否等于期待和。
* 弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点

## 55-I 二叉树的深度

## 55-II 平衡二叉树

