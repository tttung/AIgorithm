# 递归

递归，分治算法，动态规划，贪心算法的区别和联系；分治算法和动态规划很大程度上是递归思想基础上的，解决更具体问题的两类算法思想；贪心算法是动态规划算法的一个子集，可以更高效解决一部分更特殊的问题。

递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。

递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。

```python
def func(你今年几岁):
    // 最简子问题，结束条件
    if (你1999年几岁) return 我0岁
    // 自我调用，缩小规模
    return func(你去年几岁) + 1
```

训练逆向思考的能力。递推的思维是正常人的思维，总是看着眼前的问题思考对策，解决问题是将来时；递归的思维，逼迫我们倒着思考，看到问题的尽头，把解决问题的过程看做过去时。

第二，练习分析问题的结构，当问题可以被分解成相同结构的小问题时，你能敏锐发现这个特点，进而高效解决问题。

第三，跳出细节，从整体上看问题。再说说归并排序，其实可以不用递归来划分左右区域的，但是代价就是代码极其难以理解，大概看一下代码（归并排序在后面讲，这里大致看懂意思就行，体会递归的妙处）：

```
/* 我还是选择递归，简单，漂亮 */
void sort(Comparable[] a, int lo, int hi) {
    if (lo >= hi) return;
    int mid = lo + (hi - lo) / 2;
    sort(a, lo, mid); // 排序左半边
    sort(a, mid + 1, hi); // 排序右半边
    merge(a, lo,
```

### 写递归的技巧

我的一点心得是：**明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。

# 动态规划

## 三要素

**动态规划问题的一般形式就是求最值**。重叠子问题、最优子结构、状态转移方程是动态规划三要素。

**求解动态规划的核心问题是穷举**。因为要求最值，要把所有可行的答案穷举出来，然后在其中找最值。动态规划这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「DP table」来优化穷举过程，避免不必要的计算。而且，动态规划问题一定会**具备「最优子结构」**即子问题间必须互相独立，才能通过子问题的最值得到原问题的最值。另外，只有列出**正确的「状态转移方程**」才能正确地穷举。

只要通过状态转移方程写出暴力递归解，剩下的就是优化递归树，消除重叠子问题。通过「dp table」的方法来优化递归树，这两种方法本质上是一样的，只是自顶向下和自底向上的不同。

## 自顶向下和自底向上

「自顶向下」递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 `f(20)`，向下逐渐分解规模，直到 `f(1)` 和 `f(2)` 触底，然后逐层返回答案，这就叫「自顶向下」。

「自底向上」直接从最底下，最简单，问题规模最小的 `f(1)` 和 `f(2)` 开始往上推，直到推到我们想要的答案 `f(20)`，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

## **如何列出正确的状态转移方程**？

「状态转移方程」实际上就是描述问题结构的数学形式：把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移。

状态转移方程的思维框架：

->**明确「状态」** ，也就是原问题和子问题中变化的变量

-> **定义 dp 数组/函数的含义** 

-> **明确「选择」并择优**，对于每个状态，可以做出什么选择改变当前状态

**->明确 base case**

解决“如何穷举”的问题，难点在，一很多穷举需要递归实现，二有的问题本身的解空间复杂，不那么容易穷举完整。

```python
#自底向上使用 dp table 来消除重叠子问题
def dp( ) {
    #dp数组大小为子问题个数
    #base case
    for i in range(len(dp):
        #内层 for 在求所有子问题 + 1 的最小值
        #状态转移方程
    return dp[-1] 
```

# 回溯

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

# 二分查找

常用场景：寻找一个数、寻找左侧边界、寻找右侧边界。

```python
def binarySearch(nums, target):
    left = 0
    right = ...
    while ... :
        mid = left + int((right-left)/2)
        if nums[mid] == target:
            ...
        elif nums[mid] < target:
            left = ...
        elif nums[mid] > target:
            right = ...
    return ...
```

1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。

2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。

3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 `nums[mid] == target` 时做修改即可，搜索右侧时需要减一。

4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 `nums[mid] == target` 条件处的代码和返回的逻辑即可

# 滑动窗口

遇到子串问题，首先想到的就是滑动窗口

```python
left = 0
right = 0
while right < len(s):
    window.add(s[right])
    right++
    
    while valid:
        window.remove(s[left])
        left++
```

其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。

稍微麻烦的就是这个 valid 条件，为了实现这个条件的实时更新，可能会写很多代码。

# 双指针

双指针技巧可分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。

## 快慢指针

一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。

**判定链表中是否含有环**

用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

 **已知链表中含有环，返回这个环的起始位置**

当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

**寻找链表的中点**

让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。

寻找链表中点的一个重要作用是对链表进行归并排序。回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。

**寻找链表的倒数第 k 个元素**

让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点

## 左右指针

左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = len(nums) - 1 

**二分查找**

**两数之和**

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小

**反转数组**

**滑动窗口算法**